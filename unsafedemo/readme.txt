https://www.sohu.com/a/319106990_657921
https://studygolang.com/articles/28391?fr=sidebar

一、指针类型
1.简介
    在正式介绍 unsafe 包之前，需要着重介绍 Go 语言中的指针类型。
    我开始学编程的时候，第一门语言就是 C。之后又陆续学过 C++，Java，Python，这些语言都挺强大的，但是没了 C 语言那么“单纯”。
    直到我开始接触 Go 语言，又找到了那种感觉。
    Go 语言的作者之一 Ken Thompson 也是 C 语言的作者。
    所以，Go 可以看作 C 系语言，它的很多特性都和 C 类似，指针就是其中之一。
    然而，Go 语言的指针相比 C 的指针有很多限制。
    这当然是为了安全考虑，要知道像 Java/Python 这些现代语言，生怕程序员出错，哪有什么指针（这里指的是显式的指针）？
    更别说像 C/C++ 还需要程序员自己清理“垃圾”。
    所以对于 Go 来说，有指针已经很不错了，仅管它有很多限制。
    todo:golang支持指针类型，指针类型的变量存的是一个内存地址，这个地址指向的内存空间存的才是一个具体的值。
2.相比于 C 语言中指针的灵活，Go 的指针多了一些限制。但这也算是 Go 的成功之处：既可以享受指针带来的便利，又避免了指针的危险性。

    (1)限制一：Go的指针不能进行数学运算。

    来看一个简单的例子：
        ```
        a := 5
        p := &a
        p++
        p = &a + 3
        ```
    上面的代码将不能通过编译，会报编译错误：invalid operation，也就是说不能对指针做数学运算。

    (2)限制二：不同类型的指针不能相互转换。

    例如下面这个简短的例子：
    ```
    func main() {
       a := int(100)
       var f *float64
       f = &a
    }
    ```
    也会报编译错误：

    cannot use &a (type *int) as type *float64 in assignment
    关于两个指针能否相互转换，参考资料中 go 101 相关文章里写得非常细，这里我不想展开。
    个人认为记住这些没有什么意义，有完美主义的同学可以去阅读原文。当然我也有完美主义，但我有时会克制，嘿嘿。

    (3)限制三：不同类型的指针不能使用==或!=比较。
    只有在两个指针类型相同或者可以相互转换的情况下，才可以对两者进行比较。另外，指针可以通过 ==和 !=直接和 nil作比较。

    (4)限制四：不同类型的指针变量不能相互赋值。
    这一点同限制三。



二、什么是unsafe

      前面所说的指针是类型安全的，但它有很多限制。Go 还有非类型安全的指针，这就是 unsafe 包提供的 unsafe.Pointer。在某些情况下，它会使代码更高效，当然，也更危险。

      unsafe 包用于 Go 编译器，在编译阶段使用。从名字就可以看出来，它是不安全的，官方并不建议使用。我在用 unsafe 包的时候会有一种不舒服的感觉，可能这也是语言设计者的意图吧。

      但是高阶的 Gopher，怎么能不会使用 unsafe 包呢？它可以绕过 Go 语言的类型系统，直接操作内存。例如，一般我们不能操作一个结构体的未导出成员，但是通过 unsafe 包就能做到。
      unsafe 包让我可以直接读写内存，还管你什么导出还是未导出。




三、为什么有unsafe

   Go 语言类型系统是为了安全和效率设计的，有时，安全会导致效率低下。
   有了 unsafe 包，高阶的程序员就可以利用它绕过类型系统的低效。
   因此，它就有了存在的意义，阅读 Go 源码，会发现有大量使用 unsafe 包的例子。

四、unsafe如何使用

unsafe 包提供了 2 点重要的能力：
  (1)任何类型的指针和 unsafe.Pointer 可以相互转换。
  (2)uintptr 类型和 unsafe.Pointer 可以相互转换。


1.获取slice长度
2.获取map长度
3.map源码中的应用
4.Offsetof获取成员偏移量
5.string和slice的相互转换

五、总结